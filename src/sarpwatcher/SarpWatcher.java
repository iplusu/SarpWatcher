/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * SarpWatcher.java
 *
 * Created on 2010. 1. 22, 오후 10:55:33
 */

package sarpwatcher;

import java.awt.Component;
import java.util.ArrayList;
import javax.swing.JFileChooser;
import javax.swing.filechooser.FileNameExtensionFilter;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;


/**
 *
 * @author Administrator
 */
public class SarpWatcher extends javax.swing.JFrame {
    private NodeMap nm;
    //private NodeProperties np;
    private DefaultTreeModel tmModel;
    private JFileChooser fc;
    private XmlParser xmlParser;
    private ThroughputChart throughputChart;
    private TrustChartSelector tcs;
    private ArrayList<TrustArraySet> trustArraySet;
    private ArrayList<TrustChart> trustChartSet;
    private ArrayList<ThroughputArraySet> throughputArraySet;
    private ArrayList<AttackArraySet> attackArraySet;
    private ArrayList<ParentArraySet> parentArraySet;
    private DatagramServer udpServer;
    private NssParser nsp;
    public enum TYPE {TRAFFIC_GENERATOR, SELECTIVE_FORWARD, LOOP_CREATOR, ON_OFF, NO_RESPONSE};

    /** Creates new form SarpWatcher */
    public SarpWatcher() {
        initComponents();
        this.setDefaultCloseOperation(EXIT_ON_CLOSE);
//        fc = new JFileChooser(".");
//        nm = new NodeMap(jpNodeMap);
//        np = new NodeProperties();
        xmlParser = new XmlParser();
        tfSourceNode.requestFocus();
        nsp = new NssParser();
        initSets();
        //nsp = new NssParser();
    }

    private void initSets() {
        if (udpServer != null && udpServer.isAlive()) {
            try {
                udpServer.StopServer();
                udpServer.join();
                udpServer = null;
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        if (trustChartSet != null && trustChartSet.size() != 0) {
            for (int i = 0; i < trustChartSet.size(); i++) {
                TrustChart tc = trustChartSet.get(i);
                if (tc.isVisible()) {
                    tc.setVisible(false);
                    tc = null;
                }
            }
        }
        if (throughputChart != null && throughputChart.isVisible()) {
            throughputChart.setVisible(false);
            throughputChart = null;
        }
        if (tcs != null && tcs.isVisible()) {
            tcs.setVisible(false);
            tcs = null;
        }
        if (nm != null && nm.isVisible()) {
            nm.setVisible(false);
            nm = null;
        }
        jbWatch.setEnabled(true);

        throughputArraySet = new ArrayList<ThroughputArraySet>();
        trustArraySet = new ArrayList<TrustArraySet>();
        trustChartSet = new ArrayList<TrustChart>();
        attackArraySet = new ArrayList<AttackArraySet>();
        parentArraySet = new ArrayList<ParentArraySet>();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        bGroupType = new javax.swing.ButtonGroup();
        jpmTreeDelete = new javax.swing.JPopupMenu();
        jmiDelete = new javax.swing.JMenuItem();
        jLabel2 = new javax.swing.JLabel();
        tfDestinationNode = new javax.swing.JTextField();
        jLabel1 = new javax.swing.JLabel();
        tfSourceNode = new javax.swing.JTextField();
        jPanel2 = new javax.swing.JPanel();
        rbTrafficGenerator = new javax.swing.JRadioButton();
        rbSelectiveForwarder = new javax.swing.JRadioButton();
        rbOnOffAttacker = new javax.swing.JRadioButton();
        jbGenerate = new javax.swing.JButton();
        jbWatch = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        jtNodeProperties = new javax.swing.JTree();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        tfSFDenominator = new javax.swing.JTextField();
        tfSFNumerator = new javax.swing.JTextField();
        jLabel5 = new javax.swing.JLabel();
        tfGoodBehaviors = new javax.swing.JTextField();
        jLabel6 = new javax.swing.JLabel();
        tfBadBehaviors = new javax.swing.JTextField();
        jMenuBar1 = new javax.swing.JMenuBar();
        jmFile = new javax.swing.JMenu();
        jMenu2 = new javax.swing.JMenu();
        jmOpenTopology = new javax.swing.JMenuItem();
        jmSaveSTP = new javax.swing.JMenuItem();
        jMenu1 = new javax.swing.JMenu();
        jmLoadResult = new javax.swing.JMenuItem();
        jmSaveResult = new javax.swing.JMenuItem();
        jmGenerateHeader = new javax.swing.JMenuItem();
        jmAnalysis = new javax.swing.JMenuItem();
        jmExit = new javax.swing.JMenuItem();
        jmHelp = new javax.swing.JMenu();

        jmiDelete.setText("Delete");
        jmiDelete.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jmiDeleteActionPerformed(evt);
            }
        });
        jpmTreeDelete.add(jmiDelete);

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("SARP Watcher");
        setResizable(false);

        jLabel2.setText("Victim Node :");

        tfDestinationNode.setEnabled(false);

        jLabel1.setText("Target Node :");

        jPanel2.setBorder(javax.swing.BorderFactory.createTitledBorder("Node Type"));

        bGroupType.add(rbTrafficGenerator);
        rbTrafficGenerator.setSelected(true);
        rbTrafficGenerator.setText("Traffic Generator");
        rbTrafficGenerator.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                bGroupTypeClicked(evt);
            }
        });

        bGroupType.add(rbSelectiveForwarder);
        rbSelectiveForwarder.setText("Selective Forwarder");
        rbSelectiveForwarder.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                bGroupTypeClicked(evt);
            }
        });

        bGroupType.add(rbOnOffAttacker);
        rbOnOffAttacker.setText("On/Off Attacker");
        rbOnOffAttacker.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                bGroupTypeClicked(evt);
            }
        });

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(rbTrafficGenerator)
                    .addComponent(rbSelectiveForwarder)
                    .addComponent(rbOnOffAttacker))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addComponent(rbTrafficGenerator)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(rbSelectiveForwarder)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(rbOnOffAttacker))
        );

        jbGenerate.setText("Generate");
        jbGenerate.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jbGenerateMouseClicked(evt);
            }
        });

        jbWatch.setText("Start");
        jbWatch.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jbWatchMouseClicked(evt);
            }
        });

        jtNodeProperties.setBorder(javax.swing.BorderFactory.createTitledBorder("Node Properties"));
        javax.swing.tree.DefaultMutableTreeNode treeNode1 = new javax.swing.tree.DefaultMutableTreeNode("Node Type");
        javax.swing.tree.DefaultMutableTreeNode treeNode2 = new javax.swing.tree.DefaultMutableTreeNode("Traffic Generator");
        treeNode1.add(treeNode2);
        treeNode2 = new javax.swing.tree.DefaultMutableTreeNode("Selective Forwarder");
        treeNode1.add(treeNode2);
        treeNode2 = new javax.swing.tree.DefaultMutableTreeNode("On/Off Attacker");
        treeNode1.add(treeNode2);
        jtNodeProperties.setModel(new javax.swing.tree.DefaultTreeModel(treeNode1));
        jtNodeProperties.setAutoscrolls(true);
        jtNodeProperties.setComponentPopupMenu(jpmTreeDelete);
        jScrollPane1.setViewportView(jtNodeProperties);

        jLabel3.setText("SF Numerator : ");

        jLabel4.setText("SF Denominator :");

        tfSFDenominator.setEnabled(false);

        tfSFNumerator.setEnabled(false);

        jLabel5.setText("Good Behaviors :");

        tfGoodBehaviors.setEnabled(false);

        jLabel6.setText("Bad Behaviors :");

        tfBadBehaviors.setEnabled(false);

        jmFile.setText("File");
        jmFile.setAutoscrolls(true);

        jMenu2.setText("Topology");

        jmOpenTopology.setText("Open Topology");
        jmOpenTopology.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jmOpenTopologyActionPerformed(evt);
            }
        });
        jMenu2.add(jmOpenTopology);

        jmSaveSTP.setText("Save Topology");
        jmSaveSTP.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jmSaveSTPActionPerformed(evt);
            }
        });
        jMenu2.add(jmSaveSTP);

        jmFile.add(jMenu2);

        jMenu1.setText("Result");

        jmLoadResult.setText("Load Result");
        jmLoadResult.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jmLoadResultActionPerformed(evt);
            }
        });
        jMenu1.add(jmLoadResult);

        jmSaveResult.setText("Save Result");
        jmSaveResult.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jmSaveResultActionPerformed(evt);
            }
        });
        jMenu1.add(jmSaveResult);

        jmFile.add(jMenu1);

        jmGenerateHeader.setText("Generate Headers");
        jmGenerateHeader.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jmGenerateHeaderActionPerformed(evt);
            }
        });
        jmFile.add(jmGenerateHeader);

        jmAnalysis.setText("Analysis");
        jmAnalysis.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jmAnalysisActionPerformed(evt);
            }
        });
        jmFile.add(jmAnalysis);

        jmExit.setText("Exit");
        jmExit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jmExitActionPerformed(evt);
            }
        });
        jmFile.add(jmExit);

        jMenuBar1.add(jmFile);

        jmHelp.setText("Help");
        jmHelp.setEnabled(false);
        jMenuBar1.add(jmHelp);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 367, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel5)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(tfGoodBehaviors))
                            .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(12, 12, 12)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel6)
                            .addComponent(jLabel2)
                            .addComponent(jLabel1)
                            .addComponent(jLabel4)
                            .addComponent(jLabel3))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(tfSFDenominator, javax.swing.GroupLayout.PREFERRED_SIZE, 87, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(tfSFNumerator, javax.swing.GroupLayout.PREFERRED_SIZE, 87, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(tfDestinationNode, javax.swing.GroupLayout.PREFERRED_SIZE, 87, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(tfSourceNode, javax.swing.GroupLayout.PREFERRED_SIZE, 87, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(tfBadBehaviors, javax.swing.GroupLayout.PREFERRED_SIZE, 63, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(177, 177, 177)
                        .addComponent(jbGenerate, javax.swing.GroupLayout.PREFERRED_SIZE, 95, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jbWatch, javax.swing.GroupLayout.DEFAULT_SIZE, 88, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(17, 17, 17)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE, false)
                            .addComponent(jLabel1)
                            .addComponent(tfSourceNode, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE, false)
                            .addComponent(jLabel2)
                            .addComponent(tfDestinationNode, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE, false)
                            .addComponent(jLabel3)
                            .addComponent(tfSFNumerator, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE, false)
                            .addComponent(jLabel4)
                            .addComponent(tfSFDenominator, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel6)
                    .addComponent(jLabel5)
                    .addComponent(tfGoodBehaviors, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(tfBadBehaviors, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jbGenerate)
                    .addComponent(jbWatch))
                .addGap(12, 12, 12)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 309, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void genTrafficGenerator(int src) {
        DefaultMutableTreeNode tempNode;

        tmModel = (DefaultTreeModel)jtNodeProperties.getModel();
        DefaultMutableTreeNode mtRoot = (DefaultMutableTreeNode)tmModel.getRoot();

        AttackArraySet aas = new AttackArraySet();
        aas.add(AttackArraySet.TYPE.TRAFFICGENERATOR, src);
        attackArraySet.add(aas);

        tempNode = (DefaultMutableTreeNode)mtRoot.getChildAt(0);
        tmModel.insertNodeInto(new DefaultMutableTreeNode(String.valueOf(src)), tempNode, tempNode.getChildCount());

        if (nm != null) {
            nm.setVertexColor(attackArraySet, src);
        }
    }

    private void genSelectiveForwarder(int src, int des, int numerator, int denominator) {
        DefaultMutableTreeNode tempNode;
        tmModel = (DefaultTreeModel)jtNodeProperties.getModel();
        DefaultMutableTreeNode mtRoot = (DefaultMutableTreeNode)tmModel.getRoot();

        if (src == des) {
            new MessageBox(this, "Warning", "Two Nodes cannot be same.");
            return;
        }
//        if(!(Math.abs(src-des) == 1) && !(Math.abs(src-des) == nm.nNumX)){
//            new MessageBox(this, "Warning", "Two Nodes should have been neighbors.");
//            return;
//        }
        AttackArraySet aas = new AttackArraySet();
        aas.add(AttackArraySet.TYPE.SELECTIVEFORWARDER, src, des, numerator, denominator);
        attackArraySet.add(aas);

        tempNode = (DefaultMutableTreeNode)mtRoot.getChildAt(1);
        tmModel.insertNodeInto(new DefaultMutableTreeNode(String.format("%d --> %d ( %d / %d )", src, des, numerator, denominator)), tempNode, tempNode.getChildCount());

        if (nm != null) {
            nm.setVertexColor(attackArraySet, src);
            try {
                nm.setEdgeColor(attackArraySet, String.format("%dto%d", src, des));
            } catch (NullPointerException e) {

            }
        }
    }

    private void genLoopCreator(int src, int des) {
        DefaultMutableTreeNode tempNode;
        tmModel = (DefaultTreeModel)jtNodeProperties.getModel();
        DefaultMutableTreeNode mtRoot = (DefaultMutableTreeNode)tmModel.getRoot();

        if (src == des) {
            new MessageBox(this, "Warning", "Two Nodes cannot be same.");
            return;
        }

        AttackArraySet aas = new AttackArraySet();
        aas.add(AttackArraySet.TYPE.LOOPCREATOR, src, des);
        attackArraySet.add(aas);

        tempNode = (DefaultMutableTreeNode)mtRoot.getChildAt(2);
        tmModel.insertNodeInto(new DefaultMutableTreeNode(String.format("%d --> %d", src, des)), tempNode, tempNode.getChildCount());

        if (nm != null) {
            nm.setVertexColor(attackArraySet, src);
            try {
                nm.setEdgeColor(attackArraySet, String.format("%dto%d", src, des));
            } catch (NullPointerException e) {

            }
        }
    }

    private void genNoResponse(int src) {
        DefaultMutableTreeNode tempNode;

        tmModel = (DefaultTreeModel)jtNodeProperties.getModel();
        DefaultMutableTreeNode mtRoot = (DefaultMutableTreeNode)tmModel.getRoot();

        AttackArraySet aas = new AttackArraySet();
        aas.add(AttackArraySet.TYPE.NORESPONSE, src);
        attackArraySet.add(aas);

        tempNode = (DefaultMutableTreeNode)mtRoot.getChildAt(3);
        tmModel.insertNodeInto(new DefaultMutableTreeNode(String.valueOf(src)), tempNode, tempNode.getChildCount());

        if (nm != null) {
            nm.setVertexColor(attackArraySet, src);
        }
    }

    private void genOnOffAttacker(int src, int nGoodBehaviors, int nBadBehaviors) {
        DefaultMutableTreeNode tempNode;

        tmModel = (DefaultTreeModel)jtNodeProperties.getModel();
        DefaultMutableTreeNode mtRoot = (DefaultMutableTreeNode)tmModel.getRoot();

        AttackArraySet aas = new AttackArraySet();
        aas.add(AttackArraySet.TYPE.ONOFFATTACKER, src, nGoodBehaviors, nBadBehaviors);
        attackArraySet.add(aas);

        tempNode = (DefaultMutableTreeNode)mtRoot.getChildAt(2);
        tmModel.insertNodeInto(new DefaultMutableTreeNode(String.format("%d - G: %d B: %d.", src, nGoodBehaviors, nBadBehaviors)), tempNode, tempNode.getChildCount());

        if (nm != null) {
            nm.setVertexColor(attackArraySet, src);
        }
    }

    private void expendTree() {
        tmModel = (DefaultTreeModel)jtNodeProperties.getModel();
        DefaultMutableTreeNode mtRoot = (DefaultMutableTreeNode)tmModel.getRoot();

        for (int i=0; i < attackArraySet.size() + 5; i++) {
            jtNodeProperties.expandRow(i);
        }
    }

    private void clearTextBox() {
        tfSourceNode.setText("");
        tfDestinationNode.setText("");
        tfSFNumerator.setText("");
        tfSFDenominator.setText("");
        tfSourceNode.requestFocus();
    }

    private void jbGenerateMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jbGenerateMouseClicked
        // TODO add your handling code here:
        if (tfSourceNode.getText().equals("")) {
            new MessageBox(this, "Warning", "You need to input Source Node");
            return;
        }
        int src = Integer.parseInt(tfSourceNode.getText());

        if (rbTrafficGenerator.isSelected()) {
            genTrafficGenerator(src);
        } else if (rbSelectiveForwarder.isSelected()) {
            if (tfSFNumerator.getText().equals("") || tfSFDenominator.getText().equals("")) {
                new MessageBox(this, "Warning", "You missed Numerator value or Denominator value.");
                return;
            }
            int numerator = Integer.parseInt(tfSFNumerator.getText());
            int denominator = Integer.parseInt(tfSFDenominator.getText());
            int des = Integer.parseInt(tfDestinationNode.getText());

            genSelectiveForwarder(src, des, numerator, denominator);
        } else if (rbOnOffAttacker.isSelected()) {
            if (tfGoodBehaviors.getText().equals("")) {
                new MessageBox(this, "Warning", "You missed Number of Thirty Second value.");
                return;
            }
            if (tfBadBehaviors.getText().equals("")) {
                new MessageBox(this, "Warning", "You missed Number of Thirty Second value.");
                return;
            }

            int nGoodBehaviors = Integer.parseInt(tfGoodBehaviors.getText());
            int nBadBehaviors = Integer.parseInt(tfBadBehaviors.getText());
            genOnOffAttacker(src, nGoodBehaviors, nBadBehaviors);
        }

        expendTree();
        clearTextBox();
//        nm.updateImage();
    }//GEN-LAST:event_jbGenerateMouseClicked

    private void bGroupTypeClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_bGroupTypeClicked
        // TODO add your handling code here:
        tfDestinationNode.setEnabled(false);
        tfSFNumerator.setEnabled(false);
        tfSFDenominator.setEnabled(false);
        tfGoodBehaviors.setEnabled(false);
        tfBadBehaviors.setEnabled(false);

        if (rbSelectiveForwarder.isSelected()) {
            tfDestinationNode.setEnabled(true);
            tfSFNumerator.setEnabled(true);
            tfSFDenominator.setEnabled(true);
        } else if (rbOnOffAttacker.isSelected()) {
            tfGoodBehaviors.setEnabled(true);
            tfBadBehaviors.setEnabled(true);
        }
        tfSourceNode.requestFocus();
    }//GEN-LAST:event_bGroupTypeClicked

    private void jmiDeleteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jmiDeleteActionPerformed
        // TODO add your handling code here:
        try {
            DefaultMutableTreeNode dtSelected = (DefaultMutableTreeNode)jtNodeProperties.getLastSelectedPathComponent();
            DefaultMutableTreeNode dtParent = (DefaultMutableTreeNode)dtSelected.getParent();
            DefaultMutableTreeNode dtRoot = (DefaultMutableTreeNode)dtParent.getParent();
            dtSelected.removeFromParent();
            //dtParent.remove(dtSelected);
            for (int i=0; i < dtRoot.getChildCount(); i++) {
                jtNodeProperties.collapseRow(i+1);
                jtNodeProperties.expandRow(i+1);
            }
        } catch (Exception e) {

        }
    }//GEN-LAST:event_jmiDeleteActionPerformed

    private void jmGenerateHeaderActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jmGenerateHeaderActionPerformed
        // TODO add your handling code here:
        fc = new JFileChooser(".");
        fc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
        int result = fc.showSaveDialog((Component)this);
        if (result == JFileChooser.APPROVE_OPTION) {
            HeaderGenerator hg = new HeaderGenerator(fc.getSelectedFile(), attackArraySet);
            hg.writeHeader();
        }
    }//GEN-LAST:event_jmGenerateHeaderActionPerformed

    private void jmExitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jmExitActionPerformed
        // TODO add your handling code here:
        System.exit(0);
    }//GEN-LAST:event_jmExitActionPerformed

    private void jbWatchMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jbWatchMouseClicked
        // TODO add your handling code here:
        try {
            udpServer = new DatagramServer(this);
        } catch (Exception e) {
            e.printStackTrace();
        }
        udpServer.start();
        throughputChart = new ThroughputChart("Throughput History");
//        throughputChart.pack();
//        throughputChart.setVisible(true);
        jbWatch.setEnabled(false);
        tcs = new TrustChartSelector(this);
//        nm.updateImage();
    }//GEN-LAST:event_jbWatchMouseClicked

    private void displayNodeMap(String nssFile) {
        nm = new NodeMap(this);
        nsp = new NssParser(nssFile, nm);
        nsp.start();
    }

    private void jmOpenTopologyActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jmOpenTopologyActionPerformed
        // TODO add your handling code here:
        fc = new JFileChooser(".");
        fc.setFileSelectionMode(JFileChooser.FILES_ONLY);
        FileNameExtensionFilter ff = new FileNameExtensionFilter("Topology (*.nss); SARP Topology (*.stp)", "nss", "stp");
        fc.setFileFilter(ff);
        int result = fc.showOpenDialog((Component)this);
        if (result == JFileChooser.APPROVE_OPTION) {
            initSets();
            String file = fc.getSelectedFile().getAbsolutePath().toString().toLowerCase();
            if (!file.endsWith(".nss") && !file.endsWith(".stp")) {
                new MessageBox(this, "Error", "Wrong Topology Type");
                return;
            }
            if (file.endsWith(".nss")) {
                displayNodeMap(file);
            } else if (file.endsWith(".stp")) {
                Replayer replayer = new Replayer(file);
                XmlReader xmlReader = replayer.readAll();
                doTopology(xmlReader);
            }
        }
    }//GEN-LAST:event_jmOpenTopologyActionPerformed

    private void jmSaveResultActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jmSaveResultActionPerformed
        // TODO add your handling code here:
        fc = new JFileChooser(".");
        fc.setFileSelectionMode(JFileChooser.FILES_ONLY);
        FileNameExtensionFilter ff = new FileNameExtensionFilter("SARP Replay (*.sre)", "sre");
        fc.setFileFilter(ff);
        int result = fc.showSaveDialog((Component)this);
        if (result == JFileChooser.APPROVE_OPTION) {
            String file = fc.getSelectedFile().getAbsoluteFile().toString().toLowerCase();
            if (!file.endsWith(".sre"))  file = file + ".sre";
            Replayer replayer = new Replayer(file);
            replayer.saveAll(nsp.getFilePath(), attackArraySet, throughputArraySet, trustArraySet, parentArraySet);
        }
    }//GEN-LAST:event_jmSaveResultActionPerformed

    private void doReplay(XmlReader xmlReader) {
        int cnt = 0;
        if (throughputChart != null) {
            throughputChart.setVisible(false);
            remove(throughputChart);
        }
        if (tcs != null) {
            tcs.setVisible(false);
            remove(tcs);
        }
        if (nm != null) {
            nm.setVisible(false);
            remove(nm);
        }

        throughputChart = new ThroughputChart("Throughput History");
        jbWatch.setEnabled(false);
        tcs = new TrustChartSelector(this);

        if (xmlReader.nssPath != null) {
            displayNodeMap(xmlReader.nssPath);
        }
        if (xmlReader.attackSet != null) {
            for (cnt = 0; cnt < xmlReader.attackSet.size(); cnt++) {
                AttackArraySet tmpAas = xmlReader.attackSet.get(cnt);
                if (tmpAas.type == AttackArraySet.TYPE.TRAFFICGENERATOR) {
                    genTrafficGenerator(tmpAas.target);
                } else if (tmpAas.type == AttackArraySet.TYPE.SELECTIVEFORWARDER) {
                    genSelectiveForwarder(tmpAas.target, tmpAas.victim, tmpAas.SF_numerator, tmpAas.SF_denominator);
                } else if (tmpAas.type == AttackArraySet.TYPE.LOOPCREATOR) {
                    genLoopCreator(tmpAas.target, tmpAas.victim);
                } else if (tmpAas.type == AttackArraySet.TYPE.NORESPONSE) {
                    genNoResponse(tmpAas.target);
                } else if (tmpAas.type == AttackArraySet.TYPE.ONOFFATTACKER) {
                    genOnOffAttacker(tmpAas.target, tmpAas.nGoodBehaviors, tmpAas.nBadBehaviors);
                }
            }
        }
        if (xmlReader.throughputSet != null) {
            for (cnt = 0; cnt < xmlReader.throughputSet.size(); cnt++) {
                ThroughputArraySet tmpTas = xmlReader.throughputSet.get(cnt);
                addThroughputArray(tmpTas.transaction, tmpTas.throughput);
                addThroughputChart(tmpTas.transaction, tmpTas.throughput);
            }
        }
        if (xmlReader.trustSet != null) {
            for (cnt = 0; cnt < xmlReader.trustSet.size(); cnt++) {
                TrustArraySet tmpTas = xmlReader.trustSet.get(cnt);
                tcs.addNode(tmpTas.source, tmpTas.target);
                addTrustArray(tmpTas.transaction, tmpTas.time, tmpTas.source, tmpTas.target, tmpTas.trustFP, /*tmpTas.trustLP,*/ tmpTas.trustPR, tmpTas.overall);
                addTrustChart(tmpTas.transaction, tmpTas.time, tmpTas.source, tmpTas.target, tmpTas.trustFP, /*tmpTas.trustLP,*/ tmpTas.trustPR, tmpTas.overall);
            }
        }
        if(xmlReader.parentSet != null){
            this.parentArraySet = new ArrayList<ParentArraySet>();
            for(cnt = 0; cnt < xmlReader.parentSet.size(); cnt++){
                this.parentArraySet.add(xmlReader.parentSet.get(cnt));
                addThroughputNotation();
            }
        }
    }

    private void doTopology(XmlReader xmlReader) {
        int cnt = 0;
        if (nm != null) {
            nm.setVisible(false);
            remove(nm);
        }

        if (xmlReader.nssPath != null) {
            displayNodeMap(xmlReader.nssPath);
        }
        if (xmlReader.attackSet != null) {
            for (cnt = 0; cnt < xmlReader.attackSet.size(); cnt++) {
                AttackArraySet tmpAas = xmlReader.attackSet.get(cnt);
                if (tmpAas.type == AttackArraySet.TYPE.TRAFFICGENERATOR) {
                    genTrafficGenerator(tmpAas.target);
                } else if (tmpAas.type == AttackArraySet.TYPE.SELECTIVEFORWARDER) {
                    genSelectiveForwarder(tmpAas.target, tmpAas.victim, tmpAas.SF_numerator, tmpAas.SF_denominator);
                } else if (tmpAas.type == AttackArraySet.TYPE.LOOPCREATOR) {
                    genLoopCreator(tmpAas.target, tmpAas.victim);
                } else if (tmpAas.type == AttackArraySet.TYPE.NORESPONSE) {
                    genNoResponse(tmpAas.target);
                } else if (tmpAas.type == AttackArraySet.TYPE.ONOFFATTACKER) {
                    genOnOffAttacker(tmpAas.target, tmpAas.nGoodBehaviors, tmpAas.nBadBehaviors);
                }
            }
        }
    }

    private void jmLoadResultActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jmLoadResultActionPerformed
        // TODO add your handling code here:
        fc = new JFileChooser(".");
        fc.setFileSelectionMode(JFileChooser.FILES_ONLY);
        FileNameExtensionFilter ff = new FileNameExtensionFilter("SARP Replay (*.sre)", "sre");
        fc.setFileFilter(ff);
        int result = fc.showOpenDialog((Component)this);
        if (result == JFileChooser.APPROVE_OPTION) {
            initSets();
            String file = fc.getSelectedFile().getAbsoluteFile().toString().toLowerCase();
            if (!file.endsWith(".sre")) {
                new MessageBox(this, "Error", "Wrong Replay File");
                return;
            }
            Replayer replayer = new Replayer(file);
            XmlReader xmlReader = replayer.readAll();
            doReplay(xmlReader);
        }
    }//GEN-LAST:event_jmLoadResultActionPerformed

    private void jmSaveSTPActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jmSaveSTPActionPerformed
        // TODO add your handling code here:
        fc = new JFileChooser(".");
        fc.setFileSelectionMode(JFileChooser.FILES_ONLY);
        FileNameExtensionFilter ff = new FileNameExtensionFilter("SARP Topology (*.stp)", "stp");
        fc.setFileFilter(ff);
        int result = fc.showSaveDialog((Component)this);
        if (result == JFileChooser.APPROVE_OPTION) {
            String file = fc.getSelectedFile().getAbsoluteFile().toString().toLowerCase();
            if (!file.endsWith(".stp"))  file = file + ".stp";
            Replayer replayer = new Replayer(file);
            replayer.saveTopology(nsp.getFilePath(), attackArraySet);
        }
    }//GEN-LAST:event_jmSaveSTPActionPerformed

    private void jmAnalysisActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jmAnalysisActionPerformed
        // TODO add your handling code here:
        fc = new JFileChooser(".");
        fc.setFileSelectionMode(JFileChooser.FILES_ONLY);
        FileNameExtensionFilter ff = new FileNameExtensionFilter("SARP Replay (*.sre)", "sre");
        fc.setFileFilter(ff);
        int result = fc.showOpenDialog((Component)this);
        if (result == JFileChooser.APPROVE_OPTION) {
            initSets();
            String file = fc.getSelectedFile().getAbsoluteFile().toString().toLowerCase();
            if (!file.endsWith(".sre")) {
                new MessageBox(this, "Error", "Wrong Replay File");
                return;
            }
            Analyzer analyzer = new Analyzer(file, this);
            Replayer replayer = new Replayer(file);
            XmlReader xmlReader = replayer.readAll();
            analyzer.set(xmlReader);
            analyzer.setVisible(true);
        }
    }//GEN-LAST:event_jmAnalysisActionPerformed

    private void addThroughputArray(int transaction, float throughput) {
        ThroughputArraySet tps = new ThroughputArraySet();
        tps.add(transaction, throughput);
        throughputArraySet.add(tps);
    }

    private void addThroughputChart(int transaction, float throughput) {
        throughputChart.addValues(transaction, throughput);
    }

    private void handleThroughput(XmlParser xmlParser) {
        addThroughputArray(xmlParser.transaction, xmlParser.throughput);
        addThroughputChart(xmlParser.transaction, xmlParser.throughput);
    }

    private void addTrustArray(int transaction, long time, int source, int target, float trustFP, /*float trustLP,*/ float trustPR, float overall) {
        TrustArraySet ts = new TrustArraySet(source, target);
        ts.addTrustValues(transaction, time, trustFP,/* trustLP,*/ trustPR, overall);
        trustArraySet.add(ts);
    }

    private void flushTrustChart(int source, int target) {
        for (int i = 0; i < trustArraySet.size(); i++) {
            TrustArraySet tmp = trustArraySet.get(i);
            if (tmp.source == source && tmp.target == target) {
                addTrustChart(tmp.transaction, tmp.time, tmp.source, tmp.target,  tmp.trustFP, /* tmp.trustLP,*/ tmp.trustPR, tmp.overall);
            }
        }
    }

    public void displayTrustChart(int source, int target) {
        boolean isExist = false;
        for (int i = 0; i < trustChartSet.size(); i++) {
            TrustChart tempChart = (TrustChart)trustChartSet.get(i);
            if (tempChart.source == source && tempChart.target == target) {
                isExist = true;
            }
        }
        if (!isExist) {
            String title = String.format("Trust Chart Source : %d / Target : %d", source, target);
            TrustChart tc = new TrustChart(title, source, target);
            tc.pack();
            tc.setVisible(true);
            trustChartSet.add(tc);
            flushTrustChart(source, target);
        }
    }

    public void closeTrustChart(int source, int target) {
        for (int i = 0; i < trustChartSet.size(); i++) {
            TrustChart tempChart = (TrustChart)trustChartSet.get(i);
            if (tempChart.source == source && tempChart.target == target) {
                tempChart.setVisible(false);
                remove(tempChart);
                trustChartSet.remove(tempChart);
                System.gc();
            }
        }
    }

    private void addTrustChart(int transaction, long time, int source, int target, float trustFP,/*float trustLP,*/ float trustPR, float overall) {
        for (int i = 0; i < trustChartSet.size(); i++) {
            TrustChart tempChart = (TrustChart)trustChartSet.get(i);
            if (tempChart.source == source && tempChart.target == target) {
//                tempChart.addValues(transaction, time, gfb, bfb, grb, brb, gab, bab, glb, blb, trustFP, trustRH, trustAV, trustLP, trustPR, overall);
                tempChart.addValues(transaction, time, trustFP,/* trustLP,*/ trustPR, overall);
            }
        }
    }

    private void handleTrust(XmlParser xmlParser) {
        tcs.addNode(xmlParser.source, xmlParser.target);
//        addTrustArray(xmlParser.transaction, xmlParser.time, xmlParser.source, xmlParser.target, xmlParser.gfb, xmlParser.bfb, xmlParser.grb, xmlParser.brb, xmlParser.gab, xmlParser.bab, xmlParser.glb, xmlParser.blb, xmlParser.trustFP, xmlParser.trustRH, xmlParser.trustAV, xmlParser.trustLP, xmlParser.trustPR, xmlParser.overall);
//        addTrustChart(xmlParser.transaction, xmlParser.time, xmlParser.source, xmlParser.target, xmlParser.gfb, xmlParser.bfb, xmlParser.grb, xmlParser.brb, xmlParser.gab, xmlParser.bab, xmlParser.glb, xmlParser.blb, xmlParser.trustFP, xmlParser.trustRH, xmlParser.trustAV, xmlParser.trustLP, xmlParser.trustPR, xmlParser.overall);
        addTrustArray(xmlParser.transaction, xmlParser.time, xmlParser.source, xmlParser.target, xmlParser.trustFP, /* xmlParser.trustLP,*/ xmlParser.trustPR, xmlParser.overall);
        addTrustChart(xmlParser.transaction, xmlParser.time, xmlParser.source, xmlParser.target, xmlParser.trustFP, /* xmlParser.trustLP,*/ xmlParser.trustPR, xmlParser.overall);
    }

    private void addThroughputNotation(){
        ParentArraySet prev_pas, cur_pas;
        StringBuilder prev_notation, cur_notation = new StringBuilder();
        int size = parentArraySet.size();
        int index = 0;

        cur_pas = parentArraySet.get(size - 1);
        if(!cur_pas.isReachedBS())  return;
        
        if(size > 1){
            prev_pas = parentArraySet.get(size - 2);
            prev_notation = new StringBuilder();

            //prev_notation.append(prev_pas.getSource(0));
            //prev_notation.append("-");
            for(index = 0; index < prev_pas.size() - 1; index++){
                prev_notation.append(prev_pas.getTarget(index));
                if(index != prev_pas.size() - 2)    prev_notation.append("-");
            }
            //cur_notation.append(cur_pas.getSource(0));
            //cur_notation.append("-");
            for(index = 0; index < cur_pas.size() - 1; index++){
                cur_notation.append(cur_pas.getTarget(index));
                if(index != cur_pas.size() - 2)    cur_notation.append("-");
            }

            if(prev_notation.toString().equals(cur_notation.toString()))
                return;
            else{
                throughputChart.addNotation(cur_notation.toString(), cur_pas.getTransaction());
                cur_pas.setMark(true);
            }
        }else{
            //cur_notation.append(cur_pas.getSource(0));
            //cur_notation.append("-");
            for(index = 0; index < cur_pas.size() - 1; index++){
                cur_notation.append(cur_pas.getTarget(index));
                if(index != cur_pas.size() - 2)    cur_notation.append("-");
            }
            throughputChart.addNotation(cur_notation.toString(), cur_pas.getTransaction());
            cur_pas.setMark(true);
        }
    }

    private void addParentArray(int transaction){
        ParentArraySet pas = null;
        if(!parentArraySet.isEmpty()){
            pas = parentArraySet.get(parentArraySet.size() - 1);
            if(pas.isNewTransaction(transaction)){
                pas = new ParentArraySet(transaction);
                parentArraySet.add(pas);
            }
        } else {
            pas = new ParentArraySet(transaction);
            parentArraySet.add(pas);
        }
    }

    private void handleParent(XmlParser xmlParser) {
        if(xmlParser.parentSource == 255 || xmlParser.parentTarget == 255)  return;
        int transaction = xmlParser.transaction;
        addParentArray(transaction);
        ParentArraySet pas = parentArraySet.get(parentArraySet.size() - 1);
        if (nm != null&& !pas.isRouteExist(xmlParser.parentSource, xmlParser.parentTarget)) {
            nm.setToParent(attackArraySet, pas);
        }
        if(pas.isSameTransaction(transaction) && !pas.isRouteExist(xmlParser.parentSource, xmlParser.parentTarget)){
            pas.add(xmlParser.parentSource,xmlParser.parentTarget);
        }
        if(!pas.getMark()) addThroughputNotation();
    }

    public void msgHandler(String xml) {
        if(xmlParser == null)
            xmlParser = new XmlParser();
        xmlParser.parse(xml);

        if (xmlParser.type == XmlParser.TYPE.THROUGHPUT) {
            handleThroughput(xmlParser);
        } else if (xmlParser.type == XmlParser.TYPE.TRUST) {
            handleTrust(xmlParser);
        } else if (xmlParser.type == XmlParser.TYPE.PARENT) {
            handleParent(xmlParser);
        }
    }

    /**
    * @param args the command line arguments
    */
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new SarpWatcher().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.ButtonGroup bGroupType;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JMenu jMenu1;
    private javax.swing.JMenu jMenu2;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JButton jbGenerate;
    private javax.swing.JButton jbWatch;
    private javax.swing.JMenuItem jmAnalysis;
    private javax.swing.JMenuItem jmExit;
    private javax.swing.JMenu jmFile;
    private javax.swing.JMenuItem jmGenerateHeader;
    private javax.swing.JMenu jmHelp;
    private javax.swing.JMenuItem jmLoadResult;
    private javax.swing.JMenuItem jmOpenTopology;
    private javax.swing.JMenuItem jmSaveResult;
    private javax.swing.JMenuItem jmSaveSTP;
    private javax.swing.JMenuItem jmiDelete;
    private javax.swing.JPopupMenu jpmTreeDelete;
    private javax.swing.JTree jtNodeProperties;
    private javax.swing.JRadioButton rbOnOffAttacker;
    private javax.swing.JRadioButton rbSelectiveForwarder;
    private javax.swing.JRadioButton rbTrafficGenerator;
    private javax.swing.JTextField tfBadBehaviors;
    private javax.swing.JTextField tfDestinationNode;
    private javax.swing.JTextField tfGoodBehaviors;
    private javax.swing.JTextField tfSFDenominator;
    private javax.swing.JTextField tfSFNumerator;
    private javax.swing.JTextField tfSourceNode;
    // End of variables declaration//GEN-END:variables

}
